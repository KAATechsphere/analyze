## Список ADR (Реестр архитектурных решений)

### 1. Архитектурный подход

**Принятое решение:** Реализация микросервисной архитектуры.

**Ключевые преимущества:**
- Высокая адаптивность: возможность использования различных технологических стеков для каждой команды
- Эффективное масштабирование: независимая настройка производительности отдельных сервисов
- Повышенная отказоустойчивость: локализация сбоев в пределах одного сервиса


### 2. Процесс развертывания

**Принятое решение:** Внедрение методологии CI/CD.

**Основные выгоды:**
- Автоматизация процессов тестирования и деплоя
- Ускорение цикла разработки и выпуска обновлений

### 3. Управление пользователями

**Принятое решение:** Разработка отдельного микросервиса для аутентификации и авторизации.

**Функциональные преимущества:**
- Модульность и независимость пользовательской логики
- Гибкая интеграция с другими компонентами системы
### 4. Обработка событий

**Принятое решение:** Внедрение серверлесс-архитектуры для обработки событий.

**Экономические и технические преимущества:**
- Оптимизация затрат: оплата только за реальное использование ресурсов
- Динамическое масштабирование: автоматическое регулирование нагрузки

### 5. Мониторинг системы

**Принятое решение:** Реализация комплексной системы мониторинга микросервисов.

**Операционные преимущества:**
- Проактивное обнаружение проблем
- Быстрое восстановление после сбоев

### 6. Система хранения данных

**Принятое решение:** Применение разнородных баз данных для различных сервисов.

**Технические преимущества:**
- Персонализация решений под конкретные задачи
- Максимальная эффективность использования ресурсов

### 7. Коммуникация между сервисами

**Принятое решение:** Использование RESTful API для межсервисного взаимодействия.

**Интеграционные преимущества:**
- Простота реализации и поддержки
- Широкая распространенность и совместимость с различными технологиями

---
### Список Architecture Decision Records (ADR)

Architecture Decision Records (ADR) — это документация важных решений, принятых в ходе разработки архитектуры системы. Они фиксируют контекст, причины и последствия выбора определенного архитектурного подхода. Ниже приведен список ADR для предлагаемой системы:

1.  **ADR-001: Выбор микросервисной архитектуры**        
    -   **Контекст:** Необходимость масштабируемости, гибкости и независимости компонентов.
        
    -   **Решение:** Принята микросервисная архитектура.
        
    -   **Причины:** Легкость масштабирования, возможность использования различных технологий для различных сервисов, независимость развертывания и обновления компонентов.
        
    -   **Последствия:** Повышенные требования к оркестрации, DevOps и управлению межсервисной коммуникацией.
        
2.  **ADR-002: Использование API Gateway**
    -   **Контекст:** Необходимость централизованного управления запросами, маршрутизацией и безопасностью.
        
    -   **Решение:** Внедрение API Gateway.
        
    -   **Причины:** Централизованная точка входа для всех запросов, улучшенная безопасность, упрощение управления аутентификацией и авторизацией.
        
    -   **Последствия:** Потенциальная точка отказа, необходимость высокой доступности и надежности Gateway.
        
3.  **ADR-003: Внедрение Event-Driven Architecture**        
    -   **Контекст:** Необходимость асинхронной обработки событий и слабосвязанной коммуникации между сервисами.
        
    -   **Решение:** Использование архитектуры, основанной на событиях.
        
    -   **Причины:** Обеспечение высокой производительности и масштабируемости, возможность добавления новых функций без изменения существующих сервисов.
        
    -   **Последствия:** Сложность управления событиями и их порядком, необходимость надежной инфраструктуры для передачи и хранения событий.
        
4.  **ADR-004: Использование Docker и Kubernetes для оркестрации контейнеров**        
    -   **Контекст:** Необходимость эффективного управления контейнерами и автоматизации развертывания.
        
    -   **Решение:** Внедрение Docker для контейнеризации и Kubernetes для оркестрации.
        
    -   **Причины:** Упрощение развертывания, масштабирования и управления приложениями, высокая степень автоматизации.
        
    -   **Последствия:** Требуется обучение команды работе с Kubernetes, необходимость настройки и поддержки кластера Kubernetes.
        
5.  **ADR-005: Выбор баз данных**        
    -   **Контекст:** Разнообразие данных и требований к их хранению и доступу.
        
    -   **Решение:** Использование комбинации реляционной базы данных (PostgreSQL) и NoSQL базы данных (MongoDB).
        
    -   **Причины:** PostgreSQL для хранения структурированных данных с поддержкой транзакций, MongoDB для хранения неструктурированных данных и высокой производительности при работе с большими объемами данных.
        
    -   **Последствия:** Повышенная сложность в управлении данными, необходимость синхронизации между различными типами баз данных.
        
6.  **ADR-006: Использование системы мониторинга и логирования (Prometheus и ELK)**        
    -   **Контекст:** Необходимость обеспечения наблюдаемости и диагностики системы.
        
    -   **Решение:** Внедрение Prometheus для мониторинга метрик и ELK (Elasticsearch, Logstash, Kibana) для централизованного логирования.
        
    -   **Причины:** Обеспечение полной видимости состояния системы, возможность быстрой диагностики и реагирования на инциденты.
        
    -   **Последствия:** Требуется настройка и поддержка инфраструктуры мониторинга и логирования, необходимость управления большими объемами логов и метрик.
        
7.  **ADR-007: Внедрение многофакторной аутентификации (MFA)**        
    -   **Контекст:** Повышенные требования к безопасности данных пользователей.
        
    -   **Решение:** Внедрение многофакторной аутентификации.
        
    -   **Причины:** Повышение уровня безопасности, предотвращение несанкционированного доступа.
        
    -   **Последствия:** Усложнение процесса аутентификации для пользователей, необходимость интеграции MFA в существующую инфраструктуру аутентификации.
        
8.  **ADR-008: Интеграция с популярными фитнес-устройствами и сервисами**        
    -   **Контекст:** Требование поддержки сторонних устройств и сервисов для отслеживания тренировок.
        
    -   **Решение:** Интеграция с устройствами и сервисами через стандартизированные API.
        
    -   **Причины:** Увеличение ценности приложения для пользователей, возможность предоставления дополнительных данных и функций.
        
    -   **Последствия:** Необходимость поддержки и обновления интеграций, обеспечение безопасности при передаче данных.
---
# Реестр архитектурных решений

## Выбор архитектурного стиля
### Контекст и бизнес-потребность
Приложение ориентировано на рост, масштабируемость и возможность независимой разработки различных функций (спорт, тренировки, соц. взаимодействие). Необходима гибкость командной разработки и устойчивость.

### Варианты решений
| Подход            | Плюсы                                                         | Минусы                                                         |
|-------------------|---------------------------------------------------------------|----------------------------------------------------------------|
| Микросервисы      | Масштабируемость, Независимое развертывание, Языковая свобода | Сложная отладка, Инфраструктурные накладные расходы            |
| Монолит           | Простота начального запуска, Проще разрабатывать              | Трудности масштабирования, Сложность при командной разработке  |
| Модульный монолит | Контроль целостности, Упрощённое тестирование                 | Средняя гибкость, Единое развертывание                         |
| SOA               | Повторное использование сервисов, Чёткие интерфейсы           | Сложный громоздкий стек, часто устаревший подход               |

### Решение
Микросервисная архитектура подходит для масштабируемого мобильного приложения, где могут работать параллельные команды. Несмотря на сложность, преимущества в гибкости и масштабировании перевешивают.

### Обоснование
  - Гибкость: Разные команды могут использовать разные технологии, что позволяет быстрее адаптироваться к новым требованиям. 
  - Масштабируемость: Легко масштабировать отдельные сервисы в зависимости от нагрузки.
  - Устойчивость: Ошибка в одном сервисе не приводит к сбою всего приложения.


## Выбор подхода к развертыванию
### Контекст и бизнес-потребность
Необходимы частые релизы, быстрая доставка новых функций и автоматизация развертываний для минимизации ошибок.

### Варианты решений
| Подход      | Плюсы                                       | Минусы                                       |
|-------------|---------------------------------------------|----------------------------------------------|
| CI/CD       | Автоматизация, Быстрые релизы, Меньше багов | Требует настройки, DevOps компетенции        |
| Ручное      | Простой старт                               | Человеческий фактор, медленное тестирование  |
| Полуавтомат | Чуть быстрее, чем вручную                   | Неустойчивая, сложная поддержка              |

### Решение
CI/CD необходим для профессиональной и быстрой доставки продукта, особенно в среде с микросервисами.

### Обоснование:
  - Упрощение процесса развертывания и тестирования.
  - Быстрая реакция на изменения и возможность частых релизов.


## Выбор технологии для управления пользователями
### Контекст и бизнес-потребность
Пользователи — ключевая сущность. Требуется их масштабируемая и изолированная обработка, потенциально с внешней авторизацией (OAuth, SSO и т.п.).

### Варианты решений
| Подход                       | Плюсы                                            | Минусы                                    |
|------------------------------|--------------------------------------------------|-------------------------------------------|
| Отдельный микросервис        | Изоляция, Лёгкая интеграция с другими сервисами  | Поддержка собственной безопасности        |
| Централизованное управление  | Просто, один кодовый путь                        | Трудно расширять, слабая масштабируемость |
| Внешний Identity Provider    | Быстро, надёжно                                  | Меньшая кастомизация, платные решения     |

### Решение
Собственный сервис — компромисс между гибкостью и контролем, особенно если нужны собственные роли, статусы и бизнес-логика.

### Обоснование:
  - Позволяет изолировать функциональность и упростить управление пользователями.
  - Обеспечивает возможность интеграции с другими сервисами.



## Выбор подхода к обработке событий
### Контекст и бизнес-потребность
Некоторые задачи должны выполняться реактивно (уведомления, аналитика, cron-задачи), и нет необходимости держать сервер 24/7.

### Варианты решений
| Подход            | Плюсы                                  | Минусы                                   |
|-------------------|----------------------------------------|------------------------------------------|
| Serverless        | Оплата за вызов, Автомасштабирование   | Холодный старт, ограничения по времени   |
| Отдельный сервис  | Контроль, предсказуемость работы       | Платите за простаивающий ресурс          |
| Worker + очередь  | Подходит для сложных и повторных задач | Требует поддержки очереди и мониторинга  |


### Решение
Serverless отлично подходит для нечастых, реактивных задач. Особенно эффективен в условиях ограниченного бюджета и нагрузки.

### Обоснование:
  - Экономия ресурсов: Платите только за фактическое использование. 
  - Автоматическое масштабирование: Легко справляться с изменениями нагрузки.


## Выбор системы мониторинга
### Контекст и бизнес-потребность
Нужно быстро выявлять и устранять сбои. Критично для микросервисной архитектуры, где сбой может быть локализован.

### Варианты решений
| Подход              | Плюсы                        | Минусы                                 |
|---------------------|------------------------------|----------------------------------------|
| Только логирование  | Просто                       | Нет проактивности, не видно узких мест |
| Мониторинг-система  | Графики, алерты, трассировка | Настройка, сложность                   |
| Простое оповещение  | Моментальные уведомления     | Сложно анализировать постфактум        |

### Решение
Без мониторинга микросервисы теряют управляемость. Выбор полноценной системы — обязательное решение.

### Обоснование
  - Необходимость в продвинутых практиках мониторинга для обеспечения устойчивости и быстрого реагирования на проблемы.


## Выбор базы данных
### Контекст и бизнес-потребность
Каждый микросервис имеет уникальные данные: например, аналитика — графовые связи, пользователи — реляционные данные.

### Варианты решений
| Подход                  | Плюсы                                    | Минусы                                  |
|-------------------------|------------------------------------------|-----------------------------------------|
| Разные БД               | Оптимизация под задачу, масштабируемость | Сложность поддержки, миграции, бэкапы   |
| Общая БД                | Упрощённый доступ, меньше DevOps         | Конфликты схем, слабая масштабируемость |
| Один тип БД, разные БД  | Централизованная поддержка               | Не оптимально под специфические задачи  |

### Решение
Разделение БД повышает гибкость, но требует зрелости в DevOps и интеграции.

### Обоснование
  - Позволяет оптимизировать производительность и хранение данных в зависимости от специфики каждого сервиса.


## Выбор протокола взаимодействия между сервисами
### Контекст и бизнес-потребность
Необходима простая и кросс-платформенная интеграция между сервисами.

### Варианты решений
| Подход        | Плюсы                                    | Минусы                                      |
|---------------|------------------------------------------|---------------------------------------------|
| REST          | Простота, Поддержка всеми платформами    | Нет строгой схемы, избыточность             |
| gRPC          | Высокая производительность               | Требует proto-файлов, не так универсален    |
| GraphQL       | Гибкие запросы, клиент сам выбирает поля | Сложнее кешировать, требует обучение        |
| Event-driven  | Асинхронность, масштабируемость          | Сложнее трассировать, нет API как такового  |

### Решение
REST — оптимальный выбор для начала, с возможностью миграции на gRPC или GraphQL при необходимости.

### Обоснование
   - Простота и распространенность RESTful API облегчают интеграцию и взаимодействие между сервисами.
---
## Список ADR
[def]: #Список-ADR
 Разделю ADR на три типа: ADR для UI/GUI-дизайнеров, ADR для фронта, ADR для бэка.
### ADR UI/GUI Дизайн
#### UI/GUI-ADR-001:
**Дата:** 2024-10-01  
**Статус:** Принято  
**Контекст:**
Приложение должно сочетать в себе функциональность интернет-магазина спортивных товаров и социальных сетей с акцентом на спортивную сферу. Поэтому важно выбрать подход к проектированию UI/GUI, который обеспечит простоту использования, узнаваемость элементов (легкое ориентирование пользователя), плюс удобство для фронт-энд разработчиков.

**Решение:**  
Использование Material Design. Это дизайн от Google, который предлагает готовую систему компонентов, что значительно ускоряет процесс разработки. Он также обеспечивает единообразный и интуитивный интерфейс благодаря ясным визуальным подсказкам и анимациям. Это будет полезно для создания как интернет-магазина, так и социальной платформы.

**Последствия:** 
Пользователи будут легко ориентироваться в приложении благодаря привычному стилю интерфейса, что может повысить удовлетворенность и удержание пользователей.
Фреймворки Vue.js, React.js, Angular поддерживают компонентный подход (Vuetify, Material UI, Angular Material).

### ADR для фронта
#### FRONT-ADR-001:
**Дата:** 2024-10-01  
**Статус:** Принято  
**Контекст:**
Необходимо быстро и недорого разработать приложение. При этом фронт-энд часть должна быть в виде микросервисов (в разработку будут привлечены люди из разных стран), монолитный фронт-энд исключается. Плюс фреймворк должен поддерживать Material Design. У используемого фреймворка должно быть большое сообщество и перспектива развития.

**Решение:**  
Использование React с Material UI будет более предподчтительным.

**Последствия:** 
React более легковесная библиотека, которая позволяет более свободно организовывать структуру приложения. Можно отдельно разрабатывать различные компоненты или модули и затем интегрировать их в приложение — это хорошо подходит для микросервисной архитектуры.

React имеет обширную экосистему со множеством сторонних библиотек и инструментов, что позволяет использовать только те инструменты, которые необходимы для выполнения конкретной задачи, что увеличивает гибкость и возможность адаптации.

React позволяет разработчикам сосредоточиться на создании отдельных компонентов, которые могут быть разработаны и протестированы независимо друг от друга, что способствует лучшему распределению задач внутри команды.

React проще интегрировать с другими библиотеками и фреймворками, что может быть полезно при построении микросервисной архитектуры, где разные службы могут требовать разных технологий.

На данный момент React по-прежнему занимает более значимую позицию на рынке труда по сравнению с Angular (проще найти людей). Это связано с его широкой популярностью и адаптивностью, а также с активной поддержкой со стороны сообщества и крупных компаний (например, Facebook).

### ADR для бэка
Здесь сосредоточусь на особенностях, связанных с принятыми архитектурными решениями (ADR), привязанными к конкретным доменам или модулям.
#### Back-ADR-001: Модуль регистрации и аутентификации

**Дата:** 2024-10-01  
**Статус:** Принято  
**Контекст:**  
Пользователи должны иметь возможность регистрироваться в системе, предоставляя свои персональные данные, и входить в систему с использованием проверенных методов аутентификации. Необходимо обеспечить регистрацию новых пользователей и аутентификацию с использованием социальных сетей и многофакторной аутентификации для повышения безопасности. 

**Решение:**  
Реализовать модуль, использующий OAuth для аутентификации через социальные сети и внедрить многофакторную аутентификацию через SMS/Email.
Использовать токены JWT (JSON Web Tokens) для аутентификации пользователей, и реализовать функционал регистрации, который включает проверку email и подтверждение учетной записи.

**Последствия:**  
Увеличение безопасности пользователей за счет многофакторной аутентификации. Использование проверенных методов аутентификации повысит доверие к системе. Наличие интеграции с социальными сетями упростит процесс регистрации, что может привести к увеличению числа пользователей.
Но увеличивается сложность разработки и тестирования, 
появляется необходимость уделить внимание безопасному хранению и передаче данных пользователей. Требуется внедрить механизмы защиты для хранения и передачи паролей, такие как шифрование и использование HTTPS. Необходимо провести аудит безопасности для предотвращения утечек личной информации.

#### Back-ADR-002: Модуль социальной сети с уклоном в спортивную сферу

**Дата:** 2024-10-04  
**Статус:** Принято  
**Контекст:**  
Модуль должен обеспечивать создание и управление социальными группами, общение между участниками и систему модерации.
Пользователи должны иметь возможность создавать и редактировать свои посты, комментарии и отзывы о товарах. А также иметь возможность взаимодействовать через комментарии, лайки и ответы.

Также необходимо обеспечить защиту от онлайн-насилия и соблюдение норм законодательства относительно обработки пользовательского контента, поэтому следует иметь эффективную систему модерации для обработки жалоб на неподобающий контент.

**Решение:**  
Реализовать функционал групп и чатов, а также модерации контента с использованием REST API и веб-сокетов для реального времени. При этом система должна быть интегрирована с модулем уведомлений для оповещений.

Создать инструмент для модераторов, где они смогут отслеживать и управлять жалобами на контент, используя административную панель.

**Последствия:**
Создание активного сообщества пользователей повысит вовлеченность и взаимодействие среди участников. Эффективная система модерации обеспечит безопасность пользователей и способствует поддержанию здоровой атмосферы обсуждения.  

#### Back-ADR-003: Модуль управления спортивным инвентарем

**Дата:** 2024-10-04  
**Статус:** Принято  
**Контекст:**  
Пользователи могут вводить данные о своей спортивной экипировке на своей странице соц. сети и получать рекомендации по обновлению инвентаря с ссылкой на товар в каталоге. Если пользователь приобрел новый инвентарь, то необходимо сохранить запись об этом в базе данных. А затем через какое-то время оповещать пользователя о том, что инвентарь необходимо сменить.

**Решение:**  
Разработать модуль с внедренной моделью машинного обучения, который будет брать введенную пользователями информации о спортивном инвентаре, а также данные о пользователе и его спортивной активности, и о ранее купленном спортивном инвентаре в приложении. На основе этих данных система будет генерировать персонализированные рекомендации по смене или покупке оборудования, включая ссылки на конкретные товары.

**Последствия:**  
Улучшение качества рекомендаций на основе индивидуальных данных пользователей.
Увеличение интереса пользователей к платформе через актуальные предложения по обновлению инвентаря.
Обеспечение механизмов проверки и валидации введенной информации.
Направление пользователей на конкретные товары может привести к росту продаж и улучшению клиентского опыта.

#### Back-ADR-004: Модуль тренировок с геймификацией

**Дата:** 2024-10-04  
**Статус:** В разработке
**Контекст:**  
Модуль должен анализировать данные о тренировках и генерировать персонализированные планы. Поощрять пользователя в случае следования планам тренировок. Данные о результатах тренировок должны сохраняться. Для того чтобы, например, пользователь мог сравнивать свои результаты тренировок, или результаты тренировок других пользователей в этом же виде спорта.

**Решение:**  
Необходимо разработать и обучить модель машинного обучения, которая будет генерировать персонализированные планы тренировок для пользователей на основе их данных о тренировках, спортивном инвентаре и информации из социальной сети приложения. В процессе создания данной модели важно привлечь тренеров различных видов спорта в качестве экспертов, чтобы обеспечить ее корректность и эффективность.

Кроме того, на основе данных из модуля интеграции с внешними устройствами следует разработать систему поощрений. При этом необходимо учесть, что некоторые пользователи могут не обладать фитнес-трекерами (сторонними устройствами), и создать систему вознаграждений, которая будет мотивировать всех пользователей, независимо от наличия дополнительных устройств.

Возможно придется хранить большие объемы данных. Предлагается использовать:
Реляционные базы данных (например, PostgreSQL, MySQL) для упорядоченных данных с четкими связями.


**Последствия:**  
Использование машинного обучения для генерации индивидуальных планов тренировок позволит учитывать особенности каждого пользователя, включая его уровень подготовки, предпочтения и цели. Это повышает эффективность тренировок и снижает риск травм. Механизмы поощрения и игровые элементы помогут удержать пользователей в приложении дольше, снижая вероятность отказа от использования. Пользователь будет возвращаться, чтобы продолжать получать новые достижения и улучшать свои результаты.

Зависимости от модуля интеграции с внешними устройствами, а также от модуля соц. сети. Необходимо уделять внимание согласованию форматов данных.

#### Back-ADR-005: Модуль уведомлений и оповещений пользователей

**Дата:** 2024-10-04  
**Статус:** Принято  
**Контекст:**  
Пользователи должны получать уведомления о достижениях и событиях, например, от модуля тренировок с геймификацией. Пользователи должны быть оповещены действиях других пользователей (интеграция с модулем соц. сети). Данный модуль будет интегрироваться со всеми системами, которые способны триггерить оповещения для пользователей соц. сети или приложения в целом.

**Решение:**  
Разработать систему уведомлений, интегрированную с другими модулями для формирования релевантной информации и ее своевременной отправки.
Модуль уведомлений будет разделен на независимые микросервисы, каждый из которых будет отвечать за различные аспекты системы уведомлений, такие как:
- Генерация уведомлений
- Отправка уведомлений

Для данного модуля будет использоваться событийно-ориентированный подход. События, такие как достижения в тренировках или активность друзей в социальных сетях, оповещения о рекомендациях сменить спортивный инвентарь и пр. будут служить триггерами для инициирования создания и отправки уведомлений. Это может быть реализовано с помощью системы управления сообщениями, например, Apache Kafka, RabbitMQ или AWS SNS.


Необходимо будет разработать систему шаблонов для различных типов уведомлений, что позволит легко настраивать содержание уведомлений в зависимости от контекста (тренировки, социальные взаимодействия и т.д.).
Потребуется создать отдельный модуль для отправки уведомлений через различные каналы (мобильные уведомления, электронная почта, sms и т.д.), настраивая методы в зависимости от предпочтений пользователей.

**Последствия:**  
В данном случае использование событийно-ориентированной архитектуры и микросервисов обеспечит устойчивую и эффективную систему оповещения, которая может легко адаптироваться к изменяющимся требованиям бизнеса и пользователей.
Из минусов: необходимость поддержания актуальности данных и сложность настройки систем уведомлений с учетом предпочтений пользователей.

#### Back-ADR-006: Модуль интеграции с внешними устройствами

**Дата:** 2024-10-04  
**Статус:** Принято  
**Контекст:**  
Модуль должен подключаться с фитнес-трекерами и другими устройствами для сбора данных о тренировках.

**Решение:**  
Изучить рынок фитнес-трекеров и сторонних wearable health monitoring devices в регионах, где будет продаваться/распространяться приложение. Выделить топ фитнес-трекеров по продажам/скачиванию на телефон топ сторонних wearable health monitoring devices. Изучить используемые ими протоколы (возможность коннекта с ними для получения данных). Использовать эти протоколы (например, Bluetooth, NFC (для установки контакта)) для интеграции с устройствами, приложениями (или уметь использовать api какого-либо распространенного приложения/устройства). Реализовать механизм обработки и нормализации данных в разных форматах, поступающих от различных носимых устройств. Создать архитектуру хранения данных, способную эффективно обрабатывать большие объемы информации (Big Data), включая систему, которая будет автоматически удалять устаревшие данные после определенного периода хранения для оптимизации места и повышения производительности. Необходимо реализовать меры по защите данных пользователей, включая шифрование и анонимизацию.

**Последствия:**  
Использование различных протоколов, способов интеграции даст возможность устанавливать стабильные соединения с устройствами различных производителей, таким образом будут собираться данные активности пользователей для их дальнейшей обработки и нормализации.

Эффективное управление большими объемами данных, включая автоматическое удаление устаревшей информации снизит затраты на хранение.

За счет нормализации данных появится возможность более эффективно проводить анализ собранных данных для извлечения полезной информации и выявления тенденций в тренировочном процессе пользователей.

#### Back-ADR-007: Модуль с каталогом товаров

**Дата:** 2024-10-04  
**Статус:** Принято  
**Контекст:**  
Необходим классический интернет-магазин для продажи спортивного оборудования. Пользователи должны иметь возможность искать товары с помощью различных фильтров: по категориям, цене, популярности и т.д. Класть товары в корзину, оплачивать их. Оформлять доставку

**Решение:**  
Создать модуль или/и выстроить интеграцию с существующими модулями, которые будen интегрироваться с платежными системами, управлять каталогом товаров, корзиной, доставкой. 
Если не реализовано: реализовать полнотекстовый поиск с возможностью фильтрации через разработку REST API. Использовать Elasticsearch для быстрой обработки запросов.
Интегрировать платежный шлюз (например, Stripe или PayPal) для обработки платежей и использования API для оформления заказа (если старые модули не используют это).

**Последствия:**  
Необходима проработка всех аспектов безопасности при обработке платежей; Необходимо гарантировать соблюдение стандартов безопасности (например, PCI DSS) и учитывать возможные риски ошибок обработки платежей. Необходимо учесть ненадежность сети интернет в случае, если будет осуществлена интеграция (по рест апи, например) с уже существующими модулями интернет-магазина.

#### Back-ADR-008: Аналитика и отчетность

**Дата:** 2024-10-04  
**Статус:** В разработке. 
**Контекст:**  
Для пользователей: cистема должна собирать и анализировать пользовательские данные для улучшения контента под каждого конкретного пользователя, и для всех пользователей в целом.
Общее (для бизнеса): cистема должна проводить общий анализ, например, спроса на определенные товары. Анализ посещаемости страниц.
Формировать отчеты.

**Решение:**
Следует разработать и обучить модель машинного обучения, которая эффективно будет подбирать контент, соответствующий спортивным интересам и предпочтениям пользователей (например, показывать товары, которые могут его заинтересовать, показывать группы пользователей с общими интересами).
Интегрировать инструменты аналитики (например, Google Analytics) и реализовать собственные отчеты с использованием BI-инструментов.

**Последствия:**

Модель ML позволит эффективно анализировать предпочтения пользователей и их поведение, что обеспечит выдачу более релевантного и интересного контента, увеличивая тем самым удовлетворенность пользователей. Персонализированные рекомендации могут способствовать большему времени, проведенному пользователями в приложении, а также повышению активности (лайки, комментарии, шеры). Индивидуально подбираемый контент может значительно увеличить вероятность повторного использования приложения, так как пользователи будут более заинтересованы в контенте, который соответствует их интересам. Модель может выявить наиболее привлекательные темы и типы контента, что поможет в дальнейшем планировании и производстве более качественного материала.
Улучшенное понимание пользовательского поведения: Инструменты аналитики позволяют собирать данные о поведении пользователей на сайте или в приложении, что помогает лучше понять их предпочтения и пути взаимодействия с продуктом. Это знание может быть использовано для оптимизации пользовательского опыта.

Интеграция с аналитическими инструментами позволяет получать данные о взаимодействии пользователей в реальном времени, что помогает быстро реагировать на изменения в поведении пользователей или в эффективности маркетинговых кампаний. BI-инструменты предоставляют мощные возможности визуализации данных, позволяя легко анализировать и интерпретировать результаты. Визуальные отчеты делают данные более доступными и понятными для всех заинтересованных сторон.
Отчеты и аналитика дают возможность анализировать данные, делать выводы и принимать обоснованные решения на основе фактических данных, а не предположений.
С помощью аналитики можно определить, какие каналы маркетинга приносят наилучшие результаты, и сосредоточить усилия и бюджет на наиболее эффективных стратегиях.
Инструменты аналитики позволяют устанавливать и отслеживать ключевые показатели эффективности (KPI), что помогает в оценке успеха бизнеса и в выявлении областей для улучшения.
С помощью аналитики можно выявлять тренды и паттерны в данных, что помогает не только в текущем управлении бизнесом, но и в долгосрочном планировании и прогнозировании.
Лучше понимая, какие тактики работают, компании могут сократить ненужные расходы и инвестировать в более продуктивные стратегии.

Возможные риски неправильной интерпретации данных и вопросы конфиденциальности пользователей; требуется соблюдение норм GDPR.

---
**ADR-1: Выбор микросервисной архитектуры**

Необходимо обеспечить масштабируемость, независимое развертывание компонентов и гибкость технологического стека.

Решение: принята микросервисная архитектура с разделением на:
  - user-service (аутентификация, профили)
  - training-service (данные тренировок)
  - devices-service (интеграция с фитнес-девайсами)
  - social-service (чаты, группы)
  - notification-service (уведомления)

Обоснование:
1. Позволяет масштабировать компоненты отдельно (например social-service при росте аудитории);
2. Не зависит от единой технологии;
3. Соответствует требованиям к отказоустойчивости.

Последствия:
1. Усложнение мониторинга (необходим Prometheus + Grafana).
2. Требуется Kubernetes для оркестрации.

**ADR-2: Использование Multi-Cloud**

Компания не хочет зависеть от одного облачного провайдера.

Решение: например, основной провайдер – AWS, резервный – Google Cloud.

Обоснование:
1. AWS предоставляет лучшие инструменты для ML-аналитики;
2. GCP – альтернатива для снижения рисков блокировки.

**ADR-3: Стратегия кеширования**

Необходимо снизить нагрузку на БД и ускорить ответы для часто запрашиваемых данных.

Решение: многоуровневая стратегия кеширования:
  - Redis для пользовательских сессий и метрик тренировок;
  - CDN для статического контента (изображения, видео);
  - Локальный кеш на мобильных устройствах;


Обоснование:
1. Redis обеспечивает время отклика <5 мс для 99% запросов;
2. Поддерживает кластеризацию и репликацию;
3. Имеет встроенные механизмы инвалидации кеша.

Последствия:
1. Необходимо реализовать механизм синхронизации кеша между сервисами;
2. Дополнительные затраты на инфраструктуру.

**ADR-4: Стратегия развертывания**

Требуется обеспечить бесперебойное обновление приложения для 1M+ пользователей.

Решение: Несколько окружений с canary-релизами.

Реализация:
  - Два идентичных production-окружения;
  - Маршрутизация через Istio;
  - Постепенный перевод трафика (15% → 50% → 100%);
  - Автоматический откат при ошибках (по метрикам Prometheus).

Преимущества:
1. Нулевое время простоя;
2. Возможность A/B тестирования функционала;
3. Минимизация риска при обновлениях.

Требования:
1. Поддержка Kubernetes;
2. Инфраструктура для хранения двух полных копий окружения.

---
# Выбор платформы мобильного приложения

## Контекст:

Мы разрабатываем мобильное приложение, которое должно обладать богатым и отзывчивым интерфейсом, быть расширяемым и безопасным, интегрироваться со множеством различных датчиков, используемых спортсменами. У нас уже есть несколько мобильных приложений, функции которых должны быть перенесены в новое, которое мы собираемся реализовать. Эти приложения написаны с использованием разных технологий.

Опции:

1. Нативное мобильное-приложение, реализуемое с использованием Kotlin, Java, Swift.
2. Кроссплатформенное мобильное-приложение, реализуемое на базе фреймворков Flutter или React Native.

Нативные приложения:

1. Плюсы:
    1. Более высокая производительность и скорость.
    2. Прямой доступ к аппаратным функциям устройства и API операционной системы.
    3. Больше свободы при реализации уникальных интерфейсов.
    4. Проще реализовать требования к безопасности приложения.
2. Минусы:
    1. Выше стоимость разработки и обслуживания.
    2. Необходимость писать свой код под каждую платформу, с использованием разных языков, что исключает возможность переиспользования кода.

Кроссплатформенные приложения:

1. Плюсы:
    1. Один и тот же код работает на всех платформах.
    2. Ниже стоимость разработки.
    3. Выше скорость реализации.
2. Минусы:
    1. Меньшая скорость и производительность приложения.
    2. Меньше возможностей в реализации уникальных интерфейсов.
    3. Сложности с интеграцией сторонних устройств.
    4. Отсутствие доступа к нативным функциям устройства.

## Решение:

Мы реализуем нативное мобильное приложение. Версия под Android реализуется на Kotlin, под iOS на Swift.

## Статус:

принято

## Последствия:

1. В нативном приложении получится реализовать гибкий и богатый UI, сделать его отзывчивым для пользователя.
2. Удастся в полной мере использовать фитнес-функции смартфона.
3. Удастся интегрировать большее количество сторонних датчиков.
4. Приложение будет более безопасным.
5. Придется затратить больше времени на написание и поддержку кода.
6. Придется разрабатывать и поддерживать одновременно два приложения: под Android и под iOS.
7. Повышается вероятность того, что в результате ошибок могут появиться различия в работе приложения на разных платформах.
8. Разработка будет дороже в силу того, что потребуется больше разработчиков и с более высокой компетенцией.

# Архитектурный подход к MVP

## Контекст:

Мы реализуем MVP и нам нужно выбрать, в каком стиле он будет реализован. Ранее, на этапе анализа требований и составления плана разработки мы выбрали Space-based подход, как наиболее подходящий для выполнения поставленной задачи. 

Space-based архитектура была выбрана как хорошо поддающаяся масштабированию, легко локализуемая и позволяющая сделать систему высоко производительной. На первом этапе разработки MVP эти характеристики также являются необходимыми.

У компании уже есть используемые продукты и новая система не должна выдерживать ту нагрузку, которую создадут пользователи переходя на нее со старых приложений.

Опции:

1. Реализовать MVP в виде монолита.
2. Реализовать MVP с использованием сервисного подхода.
3. Реализовать MVP сразу создавая Space-based архитектуру.

Монолит позволит реализовать MVP в кратчайшие сроки, но система должна хорошо поддерживать географическую распределенность и обслуживать большое количество клиентов уже на начальном этапе. Сервисный подход не решит этой проблемы. Space-based архитектура позволит уже на этапе MVP выполнить эти требования, без которых MVP строго говоря и не MVP, потому что не сможет отвечать минимальным требованиям доступности.

## Решение

Мы реализуем Space-based подход с самого начала.

## Статус:

принято

## Последствия:

1. Система с самого начала будет высокодоступной во всех географических точках, где это требуется.
2. Система с самого начала сможет справляться с большим количеством пользователей.
3. Потребуется больше времени на реализацию MVP.

# Главные компоненты системы

## Контекст:

Мы создаем MVP, выбрав Space-based подход для его реализации. Необходимо выделить основные компоненты, из которых система на данном этапе будет состоять. 

Space-based системы состоят из двух основных компонентов: processing unit и virtualized middleware. Первый их них соодержит бизнес-логику и хранилища, которыми она оперирует, второй представляет своего рода инфраструктуру, распределяя нагрузку, обеспечивая актуальность данных, масштабирование и взаимодействие между несколькими юнитами.

## Решение

Virtualized middleware будет состоять из следующих частей:

1. Messaging grid. Этот компонент будет заниматься распределением пользовательской нагрузки между юнитами.

2. Data grid. Этот компонент будет обеспечивать репликацию данных между юнитами.

3. Deployment Manager. Этот компонент будет создавать и отключать юниты по мере необходимости и служить для автоматизации масштабирования.

Processing units будут существовать во множественном числе, но каждый будет состоять из сервисов, реализующие бизнес-логику.

![Схема основных компонентов](https://raw.githubusercontent.com/ariverrun/coursework/main/assets/003%20Primary%20system%20components.png "Схема основных компонентов")

## Статус:

принято

## Последствия:

1. Система будет выдерживать высокую нагрузку за счет балансировки.
2. Система будет отличаться высокой производительностью за счет хранения части данных в памяти, а остальных данных близко к сервисами, с фоновой их репликацией.
3. Система будет автоматически масштабироваться.

# Алгоритм роутинга и балансировки на уровне Messaging Grid

## Контекст:

Мы приняли решение о том, что распределением пользовательской нагрузки между юнитами системы будет заниматься компонент Messaging Grid. Его функции должны включать маршрутизацию и балансировку запросов.

Пользователи нашей системы находятся по всему миру, причем распределены неравномерно, а также распределение может меняться в случае проведения масштабных спортивных мероприятий или выхода компании на новые рынки. 

Одним из нефункциональных требований является сопоставимо быстрое время отклика во всех регионах, где приложение будет использоваться. Также требуется соблюдать законодательство стран, где мы работаем, а в ряде государств оно требует хранения пользовательских данных на их территории.

## Решение

Для распределения пользовательской нагрузки компонент Messaging Grid будет использовать GeoDNS с маршрутизацией запроса на основании местоположения пользователя, определяемого по его IP адресу.

## Статус:

принято

## Последствия:

1. Удастся снизить время ответа за счет направления запросов пользователя к географически ближайшему серверу.
2. Можно будет легко осуществлять масштабирование за счет добавления новых юнитов в тех регионах, где это требуется.
3. Выдача пользователям локализованного контента будет осуществляться более удобным образом.
4. Геолокационные данные IP адресов могут быть неточными или устаревшими, в результате запросы некоторых пользователей могут направляться по неоптимальным маршрутам.
5. В случае нахождения пользователя в "пограничной зоне" между территориями которые обрабатываются разными юнитам, его запросы могут направляться на разные юниты, особенно при смене IP адреса и использовании мобильных сетей.

# Выделение сервисов, необходимых на первом этапе

## Контекст:

На данном этапе мы реализуем MVP, который должен представлять собой мобильное приложение, в котором пользователь сможет выбрать виды спорта, которыми он занимается, найти сообщества по ним в своей локации (или создать такие сообщества), общаться в чате с их участниками. Также в приложение должны быть встроены те функции, которые уже реализованы в других приложениях компании (специализированные приложения для спорта): измерение показателей спортсмена и планы тренировок.

Необходимо обозначить границы сервисов, которые будут выполнять все вышеперечисленные функции.

## Решение

Мы реализуем следующие сервисы:

1. Сервис пользователей (Users), который хранить данные пользователей.
2. Сервис авторизации (Auth), который обеспечивает аутентификацию пользователей.
3. Сервис тренировок (Training), который предоставляет планы тренировок и подсказки по их составлению.
4. Сервис сообществ (Groups), который предоставляет возможность пользователям объединяться в группы по интересам.
5. Сервис чата (Chats), который позволяет пользователям общаться в рамках групп. В дальнейшем его можно использовать для общения с поддержкой.
6. Сервис спортивных показателей (Athletic Metrics), который собирает метрики пользоватей, предоставляет их историю и возможности для личной аналитики.

Все эти сервисы будут объединены в рамках Process Unit.

![Сервисы первого этапа](https://raw.githubusercontent.com/ariverrun/coursework/main/assets/005%201st%20step%20required%20services.png "Сервисы первого этапа")

## Статус:

принято

## Последствия

1. Разделение на сервисы позволит их независимо масштабировать, что важно, так как они будут иметь различную нагрузку.
2. Разделение на сервисы позволит их независимо разрабатывать.
3. Выделение сервиса Users как находящегося в Process Unit потребует решения задачи по обеспечению глобальной уникальности пользователя (не может быть более одного пользователя с одним и тем же номером телефона).
4. Та же проблема касается и авторизационного сервиса.
5. Выделение Users и Auth как отдельных сервисов позволит проще использовать их для авторизации пользователей на сайте.
6. Разделение на сервисы, каждый из которых имеет свою базу данных более безопасно для пользовательских данных.

# Подход к работе с распределенными данными

## Контекст:

Мы выделили 6 сервисов, каждый из которых должен иметь свое хранилище, эти сервисы находятся в рамках одного Process Unit. Данные, как и запросы пользователей, должны быть распределены географически. Также мы должны как-то обрабатывать ситуации, когда пользователь переходит из одной зоны в другую, причем для жителей приграничных зон между регионами это переключение может происходить несколько раз в день. Также одни данные чаще считываются, другие записываются, одни данные нужны часто, другие редко.

Можно хранить полную копию данных для каждого Process Unit, но тогда мы потеряем все приемущества выбранного подхода. Можно обращаться к данным других Process Unit, но это также лишит систему всех приемуществ, к которым мы стремимся. Можно хранить только тот набор данных, что относится к Process Unit, а недостающие данные реплицировать "по требованию". 

## Решение

Каждый из выделенных сервисов имеет локальное реляционное хранилище. Часть данных поддерживается в одинаковом состоянии во всех Process Unit посредством репликации, это - все данные сервиса Training, типы метрик, списки видов спорта. Остальные данные разделены географически. 

Ряд данных реплицируется в In-Memory-Data-Grid, а именно: данные сервиса Training, типы метрик, списки видов спорта, выданные авторизационные токены.

При этом каждый Process Unit имеет свой уникальный идентификатор, который возвращается пользователю при авторизации, 
а затем последний передает его при каждом запросе (зашитым в JWT токене или в заголовке). В случае, если пользователь попадает на другой Process Unit, то это будет видно по несовпадающему идентификатору и запрос будет передан предыдущему юниту (если нет уверенности, что произошел его отказ) и данные будут асинхронно отреплицированы. Когда это произойдет, запросы пользователя будут перенаправлены на новый юнит.

## Статус:

принято

## Последствия:

1. Удастся уменьшить количество данных, хранимых каждым Process Unit и повысить среднюю скорость работы с ними.
2. Удастся повысить скорость работы с теми данными, что используются для тренировок (тот раздел системы, что должен работать наиболее быстро) и чистично аутентификации за счет переноса их в оперативную память.
3. Удастся решить проблему смены Process Unit во время использования пользователем приложения.
4. Подход с перенаправлением запросов на предыдущий юнит может привести к тому, что в случае отказа последнего мы все таки не сможем ни обработать запросы, ни отреплицировать данные.
5. Репликация данных должна происходить очень быстро, объем данных должет быть большим, это создает дополнительные трудности в реализации.
6. Описанное решение достаточно сложно и потребует много времени на разработку.

# Взаимодействие пользователей с сервисами

## Контекст:

Мы выделили шесть сервисов для реализации MVP и необходимо определиться как пользователь будет с ними взаимодействовать. Http запросы пользователя приходят с мобильного приложения, установленного на его смартфоне. Они маршрутизируются компонентов Messaging Grid. Сервисы разрабатываются независимо и объединены в Process Unit. При этом все они должны в равной мере соответствовать критериям безопасности, а также спецификация их API должна давать возможность удобным образом использовать функционал сервисов. Также есть определенные функции, которые должны реализовывать все сервисы: rate-limiting, кэширование и т.д.
 
## Решение:

Все запросы, которые поступают к сервисам (кроме тех, что посылаются другими сервисами одного Process Unit) должны проходить через слой API Gateway, который будет направлять запросы в сервисам, обеспечивать функции безопасности, rate-limiting, кэширования, управления версиями сервисов и их API.

![Использование API Gateway](https://raw.githubusercontent.com/ariverrun/coursework/main/assets/007%20Communication%20between%20user%20and%20services.png "Использование API Gateway")

## Статус:

принято

## Последствия:

1. API сервисов можно будет менять без изменений на стороне клиента.
2. Функциональности реализованная на стороне нового слоя будет работать одинаково для всех сервисов.
3. Будет проще кэшировать агрегированные данные от нескольких сервисов.
4. Будет проще проводить A/B тестирование нового функционала.
5. Прохожение запросов через дополнительный слой увеличит время его обработки (что в некоторых случаях может нивелироваться кэшированием на уровне этого слоя)
6. Новый слой становится единой точкой отказа.
7. Новый слой должен быть реализован учетом высокой нагрузки, с которой ему предстоит справляться, что увеличивает затраты на разработку.

# Выбор СУБД

## Контекст:

У нас есть 6 сервисов, которые надлежит реализовать, каждый из них имеет свои доменные сущности, которые нужно как-то хранить. Характер работы с этими сущностями приемущественно представляет собой операции чтения и записи. Обновление происходит в ограниченном круге сценариев: редактирование пользователем своего профиля, редактирование описания сообщества, изменение плана тренировки.

Существует несколько возможных опций для выбора.

1. Реляционные СУБД:
    1. Требуют наличия четкой схемы данных.
    2. Поддерживают транзакционность.
    3. Масштабируются вертикально, горизонтальное масштабирование также возможно, но является относительно сложным.
    4. Скорость доступа к данным может уступать во многих случаях другим видам СУБД, но зато сам доступ может быть очень гибким и оптимизируемым за счет индексов и других средств.
2. Нереляционные СУБД:
    1. Документоориентированные:
        1. Имеют гибкую схему данных.
        2. Хорошо масштабируются горизонтально и вертикально.
        3. Поддержка транзакций ограничена.
        4. Поддержка сложных запросов ограничена.
    2. Ключ-значение:
        1. Имеют высокую скорость доступа к данным по ключу.
        2. Хорошо масштабируются горизонтально и вертикально.
        3. Не поддерживают сложные запросы, доступ только по ключу.
    3. Столбцовые:
        1. Позволяют эффективно сжимать данные.
        2. Оптимизированы для чтения, хорошо подходят для OLAP сценариев.
        3. Хорошо масштабируются горизонтально и вертикально.
        4. Ограниченная поддержка транзакций.
    4. Семейства стобцов:
        1. Позволяют эффективно сжимать данные.
        2. Оптимизированы на запись, хорошо подходят для OLTP сценариев.
        3. Хорошо масштабируются горизонтально и вертикально.
        4. Ограниченная поддержка транзакций.
    4. Графовые:
        1. Хорошо подходят для работы с данными которые имеют очень много связей.
        2. Имеют гибкую структуру, можно легко создать новые типы взаимосвязей.
        3. Ограниченная поддержка транзакционности.
        4. Подходят для специфических сценариев связанных с обходом графов.

## Решение

Для хранения всех сущностей, кроме тех, что отдельно указаны ниже, будет использоваться реляционный подход. Для основной части сервисов и сущностей мы будем использовать PostreSQL, для сервиса тренировок MySQL, так как он будет чаще подвержен изменению сущностей, а PostreSQL хуже справляется с такими сценариями, хотя предпочтительнее в остальных.

Для хранения метрик показателей спортсменов будет использоваться база семейства столбцов, а именно Apache Cassandra, там как объем данных в этом сервисе будет очень большим, что потребует горизонтального масштабирования, а скорость записи требуется высокая.

Также для аналитических целей стоит добавить репликцию данных в столцовую СУБД для эффективной работы с OLAP сценариями.

Для быстрого полнотекстового поиска сообществ и поиска по истории сообщений, будет применяться Elastic.

В качестве хранилища кэша в Process Unit будет использоваться Redis из-за его высокой скорости работы.

## Статус:

принято

## Последствия:

1. Каждая сущность будет храниться в том виде, который наиболее оптимально подходит к сценариям работы с ней.
2. Те данные, объем которых наиболее велик будут храниться так, чтобы иметь возможность легкого масштабирования.
3. Наличие различных баз данных потребует наличия специалистов для каждой из применяемых технологий.

